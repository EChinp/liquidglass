<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Liquid Glass UI Shader</title>
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script id="fragmentShader" type="x-shader/x-fragment">
    precision highp float;
    uniform sampler2D u_background;
    uniform vec2 u_resolution;
    uniform vec2 u_mouse;
    uniform vec2 u_size;
    varying vec2 v_uv;

    float roundedBox(vec2 uv, vec2 center, vec2 size, float radius) {
        vec2 q = abs(uv - center) - size + radius;
        return length(max(q, 0.0)) - radius;
    }

    // blur sampling (9-tap box blur, centered on v_uv)
    vec3 blurBackground(vec2 uv, vec2 resolution) {
        vec3 result = vec3(0.0);
        float total = 0.0;
        float radius = 3.0; // blur kernel from -3 to +3

        for (int x = -3; x <= 3; ++x) {
            for (int y = -3; y <= 3; ++y) {
                vec2 offset = vec2(float(x), float(y)) * 2.0 / resolution; // larger spread
                float weight = exp(-(float(x * x + y * y)) / (2.0 * radius)); // Gaussian weight
                result += texture2D(u_background, uv + offset).rgb * weight;
                total += weight;
            }
        }

        return result / total;
    }

    // Simulated lens normal based on position within shape
    vec2 glassNormal(vec2 uv, vec2 center, vec2 size) {
        vec2 local = (uv - center) / size; // range [-1, 1]
        float r = length(local);
        vec2 dir = normalize(local);

        // Simulate curved normal (pointing outward near edge)
        float strength = smoothstep(0.0, 1.0, r);
        return dir * strength;
    }
    void main() {
        vec2 center = u_mouse / u_resolution;
        vec2 size = u_size / u_resolution * 0.5;
        float radius = 0.04;
        float dist = roundedBox(v_uv, center, size, radius);

        if (dist > 0.01) {
            gl_FragColor = texture2D(u_background, v_uv);
            return;
        }

        vec2 local = (v_uv - center) / size;
        float lens = dot(local, local);

        vec3 blur = blurBackground(v_uv, u_resolution);

        // -------------------------------
        //        vec2 fromCenter = (v_uv - center) / size;           // normalized position inside button [-1,1]
        //        float r = clamp(length(fromCenter), 0.0, 1.0);       // 0 at center, 1 at edge
        //        vec2 domeNormal = normalize(fromCenter) * pow(r, 2.0); // curve gets steeper at edges
        //
        //        float eta = 1.0 / 1.5;  // air to glass
        //        vec2 incident = vec2(0.0, 0.0) - domeNormal;
        //        vec2 refractVec = refract(incident, domeNormal, eta);
        //        vec2 curvedRefractUV = v_uv + refractVec * 0.03;     // tweak 0.03 for more/less distortion


        // Physically inspired edge refraction
        vec2 fromCenter = (v_uv - center) / size;
        float r = clamp(length(fromCenter), 0.0, 1.0);

        // sharper curvature near edge
        float curvature = pow(r, 4.0); // was 2.0, now 4.0 for gentler center
        vec2 domeNormal = normalize(fromCenter) * curvature;

        // reduce intensity of shift
        float eta = 1.0 / 1.5;
        vec2 incident = vec2(0.0, 0.0) - domeNormal;
        vec2 refractVec = refract(incident, domeNormal, eta);

        // reduce distortion strength
        vec2 curvedRefractUV = v_uv + refractVec * 0.015; // was 0.03
        // -------------------------------

        vec3 refractedColor = texture2D(u_background, curvedRefractUV).rgb;
        vec3 base = mix(blur, refractedColor, 0.6);


        // Fade inward from the rounded border
        float edgeFalloff = smoothstep(0.01, 0.0, dist);
        float verticalBand = 1.0 - smoothstep(-1.2, -0.2, local.y); // inverted vertical mask
        float topShadow = edgeFalloff * verticalBand;

        vec3 shadowColor = vec3(0.0);
        base = mix(base, shadowColor, topShadow * 0.1);



        float edge = 1.0 - smoothstep(0.0, 0.03, dist * -2.0);
        vec3 glow = vec3(0.5);
        vec3 color = mix(base, glow, edge * 0.1);

        float alpha = 0.85;
        gl_FragColor = vec4(color, alpha);
    }

</script>
<script id="vertexShader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 v_uv;
    void main() {
        v_uv = vec2(a_position.x, -a_position.y) * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
</script>
<script>
    const canvas = document.getElementById("canvas");
    const gl = canvas.getContext("webgl", { antialias: true });
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    });
    window.dispatchEvent(new Event("resize"));

    const vertexShaderSrc = document.getElementById("vertexShader").textContent;
    const fragmentShaderSrc = document.getElementById("fragmentShader").textContent;

    function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Shader compile error:", gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSrc);
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSrc);

    if (!vertexShader || !fragmentShader) {
        throw new Error("Shader compilation failed. Check the console for errors.");
    }

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program link error:", gl.getProgramInfoLog(program));
    }
    gl.useProgram(program);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        -1, 1,
        1, -1,
        1, 1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    const u_resolution = gl.getUniformLocation(program, "u_resolution");
    const u_mouse = gl.getUniformLocation(program, "u_mouse");
    const u_size = gl.getUniformLocation(program, "u_size");

    const background = gl.createTexture();
    const image = new Image();
    image.crossOrigin = "anonymous";
    image.src = "https://images.unsplash.com/photo-1618221195710-dd6b41faaea6?q=80&w=2000&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfDB8fGVufDB8fHx8fA%3D%3D";
    image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, background);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.uniform1i(gl.getUniformLocation(program, "u_background"), 0);
        requestAnimationFrame(draw);
    };

    let mouse = [canvas.width / 2, canvas.height / 2];

    let targetMouse = [canvas.width / 2, canvas.height / 2];
    let currentMouse = [...targetMouse];

    const enlargedSize = [200.0, 70.0];
    let targetSize = [enlargedSize[0] * .8, enlargedSize[1] * .8];
    let currentSize = [...targetSize];

    canvas.addEventListener("mousemove", e => {
        targetMouse = [e.clientX, e.clientY];
    });


    function draw() {
        // Tween position
        currentMouse[0] += (targetMouse[0] - currentMouse[0]) * 0.1;
        currentMouse[1] += (targetMouse[1] - currentMouse[1]) * 0.1;

        // Optional: animate size for hover effect (e.g., grow slightly near center)
        const defaultSize = targetSize;
        const growNearCenter = Math.exp(-Math.pow((targetMouse[0] - canvas.width / 2) / 300, 2)); // gaussian distance falloff
        targetSize[0] = defaultSize[0] + (enlargedSize[0] - defaultSize[0]) * growNearCenter;
        targetSize[1] = defaultSize[1] + (enlargedSize[1] - defaultSize[1]) * growNearCenter;

        currentSize[0] += (targetSize[0] - currentSize[0]) * 0.1;
        currentSize[1] += (targetSize[1] - currentSize[1]) * 0.1;


        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2f(u_resolution, canvas.width, canvas.height);
        gl.uniform2f(u_mouse, currentMouse[0], currentMouse[1]);
        gl.uniform2f(u_size, currentSize[0], currentSize[1]);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, background);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(draw);
    }
</script>
</body>
</html>
